import  {EventEmitter} from 'events';

import dispatcher from '../dispatchers/dispatcher';
import * as DataActions  from '../actions/DataActions';

class DataStore extends EventEmitter {
  constructor() {
    super();


    this.companyNames = [];
    this.interval = null;
    this.companyData = {};
    this.companyDataComplete = {};
    this.companyInfo = {};
    this.companyInfoComplete = {};
    this.companyMax = {};
    this.values = {};
    this.testStarted = false;

    this.init();
  }


  init() {
    DataActions.fetchCompanyNames();
    DataActions.fetchMaxAndMin();

    DataActions.testIsStarted().body;
  }

  /**
   * Receives Actions and execute methods according to its type.
   * @param action
   */
  handleActions(action) {
    let actiontype = action.type.split(":");
    let type = actiontype[0];
    let param1 = actiontype[1];

    switch (type) {
      case "FETCH_COMPANY_NAMES" :
        this.fetchCompanyNames(action.data);
        break;
      case "FETCH_COMPANY_MAX":
        this.fetchCompanyMax(action.data);
        break;
      case "FETCH_COMPANY_DATA":
        this.fetchCompanyData(action.data, param1);
        break;
      case "FETCH_COMPANY_INFO":
        this.fetchCompanyInformation(action.data, param1);
        break;
      case "SEND_VALUE":
        this.fetchValue(action.data, action.listener,action.symbol);
        break;
      case "IS_TEST_STARTED":
            this.setTestStarted(action.data);
    }

  }

  /**
   *
   * @returns {Array|*} Symbols of Companies in the database
   */
  getCompanyNames() {
    return this.companyNames;
  }

  getCompanyInformation() {
    return this.companyInfoComplete;
  }

  /**
   * Returns companydata of one company
   * @param symbol
   * @returns {*}
   */
  getCompanyData() {
    return this.companyDataComplete;
  }

  getMax() {
    return this.companyMax;
  }

  isTestStarted()
  {
    return this.testStarted;
  }

  getValue(listener, symbol) {
    return this.values[listener + ":" + symbol];
  }

  fetchValue(data, listener,symbol) {
    if (this.values[listener + ":" + symbol] !== data) {
      this.values[listener + ":" + symbol] = data;
      this.emit(listener + ":" + symbol);
    }
  }

  /**
   * Fetches Companydata and emit it to the components
   * @param data
   * @param symbol
   */
  fetchCompanyData(data, symbol) {
    this.companyData[symbol.toUpperCase()] = data;
    this.handleDataChange();
  }

  handleDataChange() {
    let keys = Object.keys(this.companyData).length;
    let length = this.companyNames.length;

    if (keys === length) {
      this.companyDataComplete = this.companyData;
      this.companyData = {};
      this.emit('data_changed');
    }
  }

  handleInfoChange() {
    let keys = Object.keys(this.companyInfo).length;
    let length = this.companyNames.length;

    if (keys === length) {
      this.companyInfoComplete = this.companyInfo;
      this.companyInfo = {};
      this.emit('info_changed');
    }
  }

  /**
   * Sets Store, when new data ist arriving and informs listener. Furthermore an Information Polling starts.
   * Triggers Information gathering.
   * @param data Data from Action
   */
  fetchCompanyNames(data) {
    DataActions.fetchCompanyInformation();
    if (!this.interval) {
      this.interval = DataActions.startCompanyPolling();
    }
    this.companyNames = (data);
    this.emit('company_names_changed');
  }


  /**
   * Puts information concerning the companies to the store
   * @param data
   * @param symbol
   */
  fetchCompanyInformation(data, symbol) {
    this.companyInfo[symbol.toUpperCase()] = data;
    this.handleInfoChange();
  }

  /**
   * Set the test to started
   * @param data
   */
  setTestStarted(data) {
    this.testStarted = data;
    console.log("Data",data);
    this.emit("test_started_changed");
  }
}

/**
 * Register Dispatcher
 * @type {DataStore}
 */
const dataStore = new DataStore();
dispatcher.register(dataStore.handleActions.bind(dataStore));

export default dataStore;